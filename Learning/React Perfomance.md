**Diffing**(дифференциация) - процесс обновления измененного элемента в DOM.

React использует концепцию виртуального DOM, чтобы свести к минимуму затраты производительности на повторный рендеринг веб-страницы, поскольку манипулирование реальным DOM обходится дорого.

Чтобы измерить производительность React приложения используется Profiler из React DevTools. Он записывает, сколько времени требуется компоненту для рендеринга, почему компонент рендерится и многое другое.

## Методы оптимизации производительности React

1. Сохранение локального состояния компонента там, где это необходимо.
	То что у нас обновляется в родительском компоненте стоит вынести в отдельный компонент, чтобы при обновлении состояния обновлялся только он.
2. Запоминание(**мемоизация**) компонентов React для предотвращения ненужного повторного рендеринга.
	В отличие от предыдущего метода повышения производительности, когда рефакторинг нашего кода дает нам прирост производительности, здесь мы обмениваем память на время. Таким образом, мы должны запоминать компонент только тогда, когда это необходимо.

	**Мемоизация** — это стратегия оптимизации, которая кэширует операцию, визуализируемую компонентом, сохраняет результат в памяти и возвращает кэшированный результат для тех же входных данных.

	По сути, если дочерний компонент получает пропсы, мемоизированный компонент поверхностно сравнивает пропсы по умолчанию и пропускает повторный рендеринг дочернего компонента, если они не изменилось.

	####  Использование React.memo()
	
	React.memo() - это HOC используемый для обертывания чисто функционального компонента, чтобы предотвратить повторный рендеринг, если пропсы, полученные в этом компоненте, никогда не меняются.

	```js
const ChildComponent = React.memo(function ChildComponent({ count }) { 
 console.log("child component is rendering"); 
 return ( 
	<div> 
		 <h2>This is a child component.</h2> 
		 <h4>Count: {count}</h4> 
	</div> 
	); 																															});
	```
	
	Если свойство count никогда не меняется, React пропустит рендеринг ChildComponent и повторно использует предыдущий результат рендеринга. Следовательно, улучшение производительности React.
	
	React.memo() работает довольно хорошо, когда мы передаем примитивные значения, такие как число в нашем примере. И, если вы знакомы с ссылочным равенством, примитивные значения всегда ссылочно равны и возвращают true, если значения никогда не меняются.
	
	С другой стороны, непримитивные значения, такие как object, которые включают в себя массивы и функции, всегда возвращают false между повторными рендерингами, потому что они указывают на разные области памяти.
	Когда мы передаем объект, массив или функцию в качестве реквизита, мемоизированный компонент всегда перерисовывается.

	Чтобы предотвратить постоянное переопределение функции/объекта/массива, можно использовать хук useCallback, который возвращает запомненную версию обратного вызова между рендерингами.
	
	Т.е. мы можем обернуть функцию в useCallback, из-за этого она будет переопределяться только при изменении зависимостей.

	Использование **useMemo**
	
	Когда свойство, которое мы передаем дочернему компоненту, представляет собой массив или объект, мы можем использовать хук useMemo для запоминания значения между рендерами. Как мы узнали выше, эти значения указывают на разные области памяти и являются совершенно новыми значениями.

	Можно использовать хук useMemo, чтобы избежать повторного вычисления одного и того же дорогостоящего значения в компоненте. Это позволяет нам запоминать эти значения и пересчитывать их только в случае изменения зависимостей.

	useMemo так же как и useCallback ожидае